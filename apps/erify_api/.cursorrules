# Eridu Services API - Cursor AI Rules

You are an expert NestJS developer working on the Eridu Services API, a livestream production management system. Follow these architectural patterns and design decisions strictly.

## Project Overview

This is a NestJS-based API for managing livestream production workflows, including studios, MCs, platforms, shows, and collaborative scheduling. The system follows a layered architecture with clear separation of concerns.

## Core Architecture Patterns

### 1. Layered Architecture
- **Admin Layer**: Administrative operations and controllers (`/admin/*` endpoints)
- **Domain Layer**: Core business logic and services
- **Infrastructure Layer**: Database access, utilities, and external services
- **Common Layer**: Shared utilities, decorators, and base classes

### 2. Module Structure
Each entity follows this consistent pattern:
```
entity/
‚îú‚îÄ‚îÄ entity.module.ts          # Domain module
‚îú‚îÄ‚îÄ entity.service.ts         # Domain service
‚îú‚îÄ‚îÄ entity.repository.ts      # Data access layer
‚îî‚îÄ‚îÄ schemas/
    ‚îî‚îÄ‚îÄ entity.schema.ts      # Zod schemas for validation/serialization

admin/entity/
‚îú‚îÄ‚îÄ admin-entity.module.ts    # Admin module
‚îú‚îÄ‚îÄ admin-entity.controller.ts # Admin controller
‚îî‚îÄ‚îÄ admin-entity.service.ts   # Admin service
```

### 3. Repository Pattern Implementation

**Base Repository**: All repositories extend `BaseRepository<T, C, U, W>` with:
- Generic type parameters: `T` (entity), `C` (create input), `U` (update input), `W` (where input)
- Soft delete support via `deletedAt` field
- Consistent CRUD operations with Prisma integration

**Repository Structure**:
```typescript
@Injectable()
export class EntityRepository extends BaseRepository<
  Entity,
  Prisma.EntityCreateInput,
  Prisma.EntityUpdateInput,
  Prisma.EntityWhereInput
> {
  constructor(private readonly prisma: PrismaService) {
    super(new EntityModelWrapper(prisma));
  }

  // Custom methods specific to entity
  async findByUid<T extends Prisma.EntityInclude = Record<string, never>>(
    uid: string,
    include?: T,
  ): Promise<Entity | Prisma.EntityGetPayload<{ include: T }> | null> {
    return this.model.findFirst({
      where: { uid, deletedAt: null },
      ...(include && { include }),
    });
  }
}
```

### 4. Service Layer Pattern

**Domain Services**: Handle business logic and coordinate with repositories
- Use branded ID generation with `UtilityService.generateBrandedId(prefix)`
- Follow consistent naming: `EntityService` with `UID_PREFIX` constant
- Support generic includes for flexible data fetching

**Admin Services**: Handle administrative operations and coordinate with domain services
- Delegate business logic to domain services
- Handle admin-specific concerns (permissions, validation, etc.)

### 5. Controller Pattern

**Admin Controllers**: Follow RESTful conventions with consistent structure

**‚ö†Ô∏è NestJS Best Practice: Use proper decorators and response handling**
```typescript
@Controller('admin/entities')
export class AdminEntityController {
  @Post()
  @HttpCode(HttpStatus.CREATED)
  @ZodSerializerDto(EntityDto)
  async createEntity(@Body() body: CreateEntityDto) {
    return this.adminEntityService.createEntity(body);
  }

  @Get()
  @HttpCode(HttpStatus.OK)
  @ZodSerializerDto(createPaginatedResponseSchema(entityDto))
  getEntities(@Query() paginationQuery: PaginationQueryDto) {
    return this.adminEntityService.getEntities(paginationQuery);
  }

  @Get(':uid')
  @HttpCode(HttpStatus.OK)
  @ZodSerializerDto(EntityDto)
  getEntity(@Param('uid') uid: string) {
    return this.adminEntityService.getEntityById(uid);
  }

  @Patch(':uid')
  @HttpCode(HttpStatus.OK)
  @ZodSerializerDto(EntityDto)
  updateEntity(@Param('uid') uid: string, @Body() body: UpdateEntityDto) {
    return this.adminEntityService.updateEntity(uid, body);
  }

  @Delete(':uid')
  @HttpCode(HttpStatus.NO_CONTENT)
  async deleteEntity(@Param('uid') uid: string) {
    await this.adminEntityService.deleteEntity(uid);
  }
}
```

**NestJS Controller Best Practices:**
- Use `@HttpCode()` decorator for explicit status codes
- Use `@ZodSerializerDto()` for response serialization
- Use `@Body()`, `@Param()`, `@Query()` decorators properly
- Return promises for async operations
- Use proper HTTP status codes (201 for creation, 204 for deletion)

## Data Patterns

### 1. ID Management (CRITICAL DESIGN DECISION)

**üö® SECURITY & PRIVACY RULE: NEVER expose internal database IDs externally**

- **Internal Database IDs**: Auto-incrementing `bigint` primary keys - **FOR INTERNAL USE ONLY**
- **External UIDs**: Branded string identifiers for all external API communication
- **UID Prefixes**: Consistent prefixes per entity (e.g., `usr_`, `clt_`, `mc_`, `srm_`)

**Why this matters:**
- Prevents enumeration attacks and data leakage
- Hides internal database structure from external clients
- Enables database schema changes without breaking external APIs
- Provides consistent, readable identifiers for debugging and support

**Implementation Rules:**
- All API endpoints use UIDs in URLs (`/admin/users/:uid`, not `/admin/users/:id`)
- All API responses map `uid` field to `id` field for external consumption
- Internal services can use database IDs for performance (joins, indexes)
- Never return database IDs in API responses

### 2. Soft Delete Pattern
- All entities support soft delete via `deletedAt` field
- Base repository automatically filters out soft-deleted records
- Use `softDelete()` method instead of `delete()` for data preservation

### 3. Data Transformation
- **Input**: snake_case from API requests
- **Internal**: camelCase in TypeScript/Prisma
- **Output**: snake_case with `uid` mapped to `id` field
- Use Zod transformers for consistent data conversion

### 4. Pagination
- Consistent pagination using `PaginationQueryDto`
- Response format: `{ data: T[], pagination: { page, limit, total, totalPages } }`
- Use `createPaginatedResponseSchema()` for response serialization

## Validation & Serialization

### 1. Zod Schema Pattern

**üö® CRITICAL: Always map internal `uid` to external `id` field**

```typescript
// Input schema (snake_case)
export const createEntitySchema = z.object({
  name: z.string().min(1),
  ext_id: z.string().optional(),
  metadata: z.record(z.unknown()).optional(),
});

// Output schema (snake_case with id mapping)
export const entitySchema = z.object({
  id: z.string(), // üö® CRITICAL: This maps to internal 'uid' field, NEVER expose database ID
  name: z.string(),
  ext_id: z.string().optional(),
  metadata: z.record(z.unknown()).optional(),
  created_at: z.date(),
  updated_at: z.date(),
});

// DTOs
export type CreateEntityDto = z.infer<typeof createEntitySchema>;
export type EntityDto = z.infer<typeof entitySchema>;
```

**Schema Transformation Rules:**
- Input: snake_case from API requests
- Internal: camelCase in TypeScript/Prisma (with `uid` field)
- Output: snake_case with `uid` mapped to `id` field
- **NEVER include database ID fields in output schemas**

**‚ö†Ô∏è CRITICAL: Internal schemas should NOT include database ID fields**
```typescript
// ‚ùå WRONG - Internal schema with database ID
export const entitySchema = z.object({
  id: z.bigint(), // This should NOT be in internal schemas
  uid: z.string(),
  // ... other fields
});

// ‚úÖ CORRECT - Internal schema without database ID
export const entitySchema = z.object({
  uid: z.string(),
  name: z.string(),
  // ... other fields (no database ID)
});

// ‚úÖ CORRECT - Output DTO maps uid to id
export const entityDto = entitySchema.transform((obj) => ({
  id: obj.uid, // Maps internal uid to external id
  name: obj.name,
  // ... other fields
}));
```

### 2. Global Validation
- `ZodValidationPipe`: Validates all incoming requests
- `ZodSerializerInterceptor`: Serializes all outgoing responses
- `HttpExceptionFilter`: Handles validation errors consistently

## Database Patterns

### 1. Prisma Integration
- Use Prisma client for type-safe database access
- Leverage Prisma's include/select for flexible data fetching
- Use Prisma types throughout the application

### 2. Relationship Handling
- Use Prisma includes for related data fetching
- Support polymorphic relationships where needed
- Maintain referential integrity through foreign keys

### 3. Migration Strategy
- Use Prisma migrations for schema changes
- Maintain backward compatibility
- Include proper indexing for performance

## Error Handling

### 1. Exception Strategy
- Use NestJS built-in exceptions (`NotFoundException`, `BadRequestException`, etc.)
- Global exception filter for consistent error responses
- Structured error responses with proper HTTP status codes

### 2. Validation Errors
- Zod validation errors are automatically handled
- Clear error messages for validation failures
- Consistent error response format

## Authentication & Authorization Integration

**üìö See Design Documentation:**
- **Current Implementation Plan**: Check `docs/roadmap/` directory for latest phase-specific authentication strategy
- **Authentication Guide**: `docs/AUTHENTICATION_GUIDE.md` - Concrete implementation examples
- **Architecture Guide**: `docs/ARCHITECTURE.md` - Authentication and authorization patterns
- **Business Requirements**: `docs/BUSINESS.md` - Authentication strategy and user access patterns

**Key Implementation Points:**
- **Current Phase Strategy**: Always check `docs/roadmap/` for the current phase's authentication approach
- **Admin Guards**: Protect all admin endpoints with appropriate authentication/authorization
- **Service-to-Service**: API key authentication for internal communication
- **Environment Config**: Add required authentication settings to `env.schema.ts`

**Follow the patterns documented in the design docs rather than duplicating code examples here.**

## Security Patterns

### 1. Input Validation
- All inputs validated with Zod schemas
- SQL injection prevention via Prisma
- Type-safe request/response handling
- Sanitize user inputs to prevent XSS

### 2. Authentication & Authorization
- **üìö See Design Docs**: Check `docs/roadmap/` directory for current phase authentication strategy
- **Token Validation**: Validate tokens from `erify_auth` service for user identification
- **Authorization Model**: Use appropriate authorization model for current phase
- **Admin Guard**: Verify admin permissions for write operations
- **Read-Only Access**: Non-admin users get read-only access to all resources
- **Service-to-Service Auth**: API key authentication for internal service communication
- **Admin Endpoint Protection**: All admin endpoints protected by appropriate guards
- **Permission Verification**: Check user permissions using current phase's authorization model

### 3. Data Protection
- **CRITICAL**: Never expose internal database IDs
- Use UIDs for all external communication
- Implement proper CORS policies
- Use HTTPS in production
- Sanitize error messages to prevent information leakage

## Performance Considerations

### 1. Database Optimization
- Indexed UID fields for fast lookups
- Soft delete pattern for data retention
- Pagination for large datasets

### 2. Caching Strategy
- Repository-level caching ready
- Service-level caching for expensive operations
- Response caching for static data

## Testing Patterns

### 1. Unit Testing
- Service layer testing with mocked dependencies
- Repository testing with in-memory database
- Utility function testing

### 2. Integration Testing
- End-to-end API testing
- Database integration testing
- Module integration testing

## Code Style & Conventions

### 1. Naming Conventions
- **Files**: kebab-case (`studio-room.service.ts`)
- **Classes**: PascalCase (`StudioRoomService`)
- **Methods**: camelCase (`createStudioRoom`)
- **Constants**: UPPER_SNAKE_CASE (`UID_PREFIX`)

### 2. Import Organization
```typescript
// External libraries
import { Injectable } from '@nestjs/common';
import type { Prisma } from '@prisma/client';

// Internal modules
import { UtilityService } from '../utility/utility.service';
import { EntityRepository } from './entity.repository';
```

### 3. Type Safety
- Use TypeScript strict mode
- Leverage Prisma generated types
- Use branded types for UIDs
- Prefer type assertions over `any`

### 4. Linting
- If you encounter linting errors, run `pnpm lint` to surface/fix issues.

## Business Logic Patterns

### 1. Entity Lifecycle
- Create ‚Üí Update ‚Üí Soft Delete
- Audit trail for all significant changes
- Status-driven workflows where applicable

### 2. Relationship Management
- Polymorphic relationships for flexible associations
- Many-to-many relationships through join tables
- Hierarchical relationships with proper constraints

### 3. Workflow Patterns
- Draft ‚Üí Confirmed ‚Üí Live ‚Üí Completed (for shows)
- Status transitions are audited
- Business rules enforced at service layer

## When Adding New Features

1. **Follow the established patterns** - Don't reinvent the wheel
2. **Use the base repository** - Extend `BaseRepository` for new entities
3. **Implement both layers** - Create both domain and admin services
4. **Add proper validation** - Use Zod schemas for all inputs/outputs
5. **Include proper error handling** - Use NestJS exceptions consistently
6. **Implement authentication** - **üìö Check `docs/roadmap/`** for current phase authentication strategy
7. **Add authorization checks** - **üìö Check `docs/roadmap/`** for current phase authorization requirements
8. **Write tests** - Follow the established testing patterns
9. **Update documentation** - Keep architecture docs current

## NestJS-Specific Best Practices

### 1. Module Organization
- Use feature-based modules (not technical layers)
- Export services from domain modules
- Import only what you need in admin modules
- Use `@Global()` decorator sparingly (only for truly global services)

### 2. Dependency Injection
- Always use constructor injection
- Prefer interfaces over concrete classes for dependencies
- Use `@Injectable()` decorator on all services
- Avoid circular dependencies

### 3. Guards and Interceptors
- Use guards for authentication/authorization
- Use interceptors for cross-cutting concerns (logging, caching)
- Apply guards at controller or method level
- Use `@UseGuards()` decorator properly

### 4. Exception Handling
- Use NestJS built-in exceptions (`NotFoundException`, `BadRequestException`)
- Create custom exceptions extending `HttpException`
- Use global exception filters for consistent error responses
- Include proper error codes and messages

### 5. Validation and Transformation
- Use class-validator with DTOs OR Zod schemas (not both)
- Apply validation pipes globally
- Use transformation pipes for data conversion
- Validate at the boundary (controllers)

## Common Anti-Patterns to Avoid

1. **üö® NEVER expose database IDs externally** - This is a critical security violation
2. **Don't bypass the service layer** - Controllers should not directly access repositories
3. **Don't skip validation** - All inputs must be validated with Zod
4. **Don't use hard deletes** - Use soft delete pattern consistently
5. **Don't mix concerns** - Keep admin and domain logic separate
6. **Don't ignore type safety** - Use proper TypeScript types throughout
7. **Don't skip error handling** - Handle all error cases appropriately
8. **Don't create circular dependencies** - Use forwardRef() if absolutely necessary
9. **Don't use @Global() excessively** - Only for truly global services
10. **Don't mix validation libraries** - Stick to Zod OR class-validator, not both
11. **üö® Don't skip authentication** - **üìö Check `docs/roadmap/`** for current phase authentication strategy
12. **Don't bypass authorization** - **üìö Check `docs/roadmap/`** for current phase authorization requirements
13. **Don't hardcode user roles** - Use Membership model for role verification
14. **Don't ignore JWT validation** - Always validate tokens from erify_auth service

## Key Files to Reference

- `src/common/repositories/base.repository.ts` - Base repository implementation
- `src/common/pagination/schema/pagination.schema.ts` - Pagination patterns
- `src/utility/utility.service.ts` - Common utilities
- `src/prisma/prisma.service.ts` - Database service
- `src/membership/membership.service.ts` - Membership and authorization logic
- `src/membership/membership.constants.ts` - Role and group type definitions
- `src/config/env.schema.ts` - Environment configuration with authentication settings
- `docs/ARCHITECTURE.md` - Detailed architecture documentation
- `docs/BUSINESS.md` - Business domain documentation
- `docs/roadmap/` - Current phase implementation plans and authentication strategies
- `docs/AUTHENTICATION_GUIDE.md` - Concrete authentication implementation guide

Remember: Consistency is key. Follow these patterns religiously to maintain code quality and team productivity.

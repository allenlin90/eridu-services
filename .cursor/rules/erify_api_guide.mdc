# Eridu Services API - Cursor AI Rules

**Applies to:** `apps/erify_api/**/*`

Expert NestJS developer for Eridu Services API (livestream production management). Follow these patterns strictly.

**üìö Implementation Status:** Check `docs/roadmap/PHASE_1.md` for current phase status. This guide focuses on **HOW** to implement, not **WHAT** is implemented.

## Core Architecture

### Module Structure
```
entity/                          admin/entity/
‚îú‚îÄ‚îÄ entity.module.ts             ‚îú‚îÄ‚îÄ admin-entity.module.ts
‚îú‚îÄ‚îÄ entity.service.ts            ‚îú‚îÄ‚îÄ admin-entity.controller.ts
‚îú‚îÄ‚îÄ entity.repository.ts         ‚îî‚îÄ‚îÄ admin-entity.service.ts
‚îî‚îÄ‚îÄ schemas/entity.schema.ts
```

### Repository Pattern
Extend `BaseRepository<T, C, U, W>` (entity, create, update, where). Soft delete via `deletedAt`.

```typescript
@Injectable()
export class EntityRepository extends BaseRepository<Entity, Prisma.EntityCreateInput, Prisma.EntityUpdateInput, Prisma.EntityWhereInput> {
  constructor(private readonly prisma: PrismaService) {
    super(new EntityModelWrapper(prisma));
  }
  
  async findByUid<T extends Prisma.EntityInclude = Record<string, never>>(
    uid: string,
    include?: T,
  ): Promise<Entity | Prisma.EntityGetPayload<{ include: T }> | null> {
    return this.model.findFirst({ where: { uid, deletedAt: null }, ...(include && { include }) });
  }
}
```

### Service Layer
- **Model Services** (`BaseModelService`): Single-entity CRUD, use `UtilityService.generateBrandedId(prefix)`, include `UID_PREFIX` constant
- **Orchestration Services**: Multi-entity coordination, transactions (use `PrismaService.executeTransaction()` directly)
- **Admin Services**: Delegate to domain services, handle admin concerns

**Transactions:** Use `prisma.$transaction()` or `prisma.executeTransaction()` for atomic operations. Prefer bulk ops: `createMany`, `updateMany`, `deleteMany`.

**Query Building:** Private `buildWhereClause()` methods for filters. Always filter `deletedAt: null` unless `include_deleted=true`. Use `Promise.all()` for parallel queries (data + count).

### Controller Pattern
```typescript
@Controller('admin/entities')
export class AdminEntityController {
  @Post()
  @HttpCode(HttpStatus.CREATED)
  @ZodSerializerDto(EntityDto)
  async createEntity(@Body() body: CreateEntityDto) {
    return this.adminEntityService.createEntity(body);
  }
  
  @Get()
  @HttpCode(HttpStatus.OK)
  @ZodSerializerDto(createPaginatedResponseSchema(entityDto))
  getEntities(@Query() query: PaginationQueryDto) {
    return this.adminEntityService.getEntities(query);
  }
  
  // Use @HttpCode(), @ZodSerializerDto(), proper decorators, HTTP status codes (201/204)
}
```

## Data Patterns

### ID Management (CRITICAL)
**üö® NEVER expose database IDs in API responses**

- **Internal**: `bigint` primary keys (internal use only)
- **External**: Branded UIDs (e.g., `usr_`, `clt_`, `mc_`, `srm_`)
- **API**: Use UIDs in URLs (`/admin/users/:uid`), map `uid` ‚Üí `id` in DTOs
- **DTOs**: Always map `uid` to `id` field, never expose database `id`

### Other Patterns
- **Soft Delete**: `deletedAt` field, use `softDelete()` method
- **Data Transformation**: Input snake_case ‚Üí Internal camelCase ‚Üí Output snake_case
- **Pagination**: `PaginationQueryDto`, `createPaginatedResponseSchema()`, use `Promise.all()` for data + count

## Validation & Serialization

### Zod Schema Pattern
```typescript
// Internal schema (matches Prisma)
export const entitySchema = z.object({
  id: z.bigint(),  // Internal only
  uid: z.string().startsWith(EntityService.UID_PREFIX),
  name: z.string(),
  createdAt: z.date(),
  updatedAt: z.date(),
  deletedAt: z.date().nullable(),
});

// Input schema (snake_case ‚Üí camelCase)
export const createEntitySchema = z.object({
  name: z.string().min(1),
}).transform((data) => ({ name: data.name }));

// ‚úÖ CORRECT: Output DTO maps uid to id, hides database id
export const entityDto = entitySchema.transform((obj) => ({
  id: obj.uid,  // Map UID to external 'id'
  name: obj.name,
  created_at: obj.createdAt,
  updated_at: obj.updatedAt,
  // Database id NOT included
}));

export class CreateEntityDto extends createZodDto(createEntitySchema) {}
export class EntityDto extends createZodDto(entityDto) {}
```

**With Relations:** Create separate `entityWithRelationsSchema` and `entityWithRelationsDto` when needed.

**Global Validation:** `ZodValidationPipe`, `ZodSerializerInterceptor`, `HttpExceptionFilter`, `ZodExceptionFilter`.

## Database Patterns

- **Prisma**: Use repository for CRUD, direct Prisma for transactions/complex queries
- **Relationships**: Use `include` for related data, `connect: { uid }` for nested creates
- **Transactions**: Wrap in `prisma.$transaction()` callback, use `tx` parameter
- **Migrations**: Prisma migrations, maintain backward compatibility, proper indexing

## Performance (CRITICAL)

**üö® Always prefer bulk operations and includes over loops**

**Bulk Operations:**
```typescript
// ‚ùå WRONG: N+1 queries
for (const item of items) await this.repository.create(item);

// ‚úÖ CORRECT: Bulk operation
await this.prisma.entity.createMany({ data: items });
```

**Include Pattern:**
```typescript
// ‚ùå WRONG: N+1 queries
const shows = await this.showRepository.findMany({});
for (const show of shows) await this.clientRepository.findOne({ id: show.clientId });

// ‚úÖ CORRECT: Single query with include
const shows = await this.showRepository.findMany({
  include: { client: true, studioRoom: true, showType: true },
});
```

**Promise.all Pattern:**
```typescript
// ‚ùå WRONG: Sequential
const user = await this.userRepository.findOne({ uid });
const client = await this.clientRepository.findOne({ uid });

// ‚úÖ CORRECT: Parallel
const [user, client] = await Promise.all([
  this.userRepository.findOne({ uid }),
  this.clientRepository.findOne({ uid }),
]);
```

**Decision Rules:** 1) Bulk ops ‚Üí `createMany`/`updateMany`/`deleteMany`, 2) Related data ‚Üí `include`, 3) Independent queries ‚Üí `Promise.all()`, 4) Sequential dependencies ‚Üí loops (rare)

## Authentication & Authorization

**üìö Check `docs/roadmap/PHASE_1.md` for current phase status. See `docs/AUTHENTICATION_GUIDE.md` (JWT) and `docs/SERVER_TO_SERVER_AUTH.md` (API keys).**

**Phase 1:** JWT validation from `erify_auth`, Membership check for admin, API keys for service-to-service.

**Service-to-Service Auth:** Extend `BaseApiKeyGuard`:
```typescript
@Injectable()
export class MyServiceApiKeyGuard extends BaseApiKeyGuard {
  constructor(configService: ConfigService<Env>) {
    super(configService, 'my-service');
  }
  protected getApiKeyFromConfig(): string | undefined {
    return this.configService.get('MY_SERVICE_API_KEY');
  }
  protected getEnvKeyName(): string {
    return 'MY_SERVICE_API_KEY';
  }
}

// Usage: @UseGuards(MyServiceApiKeyGuard)
```

## Error Handling (CRITICAL)

**üö® ALWAYS use `HttpError` utility in service layer - NEVER throw NestJS exceptions directly**

### Service Layer
```typescript
import { HttpError } from '@/common/errors/http-error.util';

// Not found errors
if (!resource) {
  throw HttpError.notFound('Resource', identifier);
}

// Bad request errors
if (invalidInput) {
  throw HttpError.badRequest('Invalid input provided');
}

// Bad request with details (for validation errors)
if (!validationResult.isValid) {
  throw HttpError.badRequestWithDetails('Validation failed', {
    errors: validationResult.errors,
  });
}

// Conflict errors (optimistic locking, duplicates)
if (versionMismatch) {
  throw HttpError.conflict('Version mismatch. Expected X, but got Y');
}

// Other status codes
throw HttpError.unauthorized('Authentication required');
throw HttpError.forbidden('Access denied');
throw HttpError.unprocessableEntity('Invalid data format');
```

**Available Methods:**
- `HttpError.notFound(resource, identifier?)` ‚Üí 404
- `HttpError.badRequest(message)` ‚Üí 400
- `HttpError.badRequestWithDetails(message, details)` ‚Üí 400 with details
- `HttpError.conflict(message)` ‚Üí 409
- `HttpError.unauthorized(message)` ‚Üí 401
- `HttpError.forbidden(message)` ‚Üí 403
- `HttpError.unprocessableEntity(message)` ‚Üí 422

**Error Messages:** Always include context (resource name and identifier) and provide clear, actionable messages.

### Repository Layer
```typescript
// ‚úÖ CORRECT: Use Prisma's built-in methods
const record = await this.prismaModel.findFirstOrThrow({
  where: { uid, deletedAt: null },
});

// Prisma throws PrismaClientKnownRequestError (P2025) if not found
// PrismaExceptionFilter automatically converts to HTTP 404
```

**Never manually throw errors in repositories** - use `findFirstOrThrow()` or `findUniqueOrThrow()` and let Prisma handle errors.

### Global Exception Filters
- **`PrismaExceptionFilter`**: Handles Prisma errors (P2002 ‚Üí 409, P2025 ‚Üí 404)
- **`ZodExceptionFilter`**: Handles validation errors (400 with details)
- **`HttpExceptionFilter`**: Handles HTTP exceptions (passes through)

**Filters are registered globally** - no need to handle Prisma errors manually.

## Code Verification & Testing

**üö® CRITICAL: Always verify code before marking task complete**

**Verification Steps:**
1. **Linting**: `pnpm lint` - Fix errors, never disable ESLint rules unless solid documented reason
2. **Testing**: `pnpm test` - All tests pass, update/add tests for new features
3. **Build**: `pnpm build` - Compiles successfully, never use `any`/`unknown` to bypass type errors

**Checklist:** ‚úÖ `pnpm lint` passes, ‚úÖ `pnpm test` passes, ‚úÖ `pnpm build` succeeds

**When to Verify:** After generating/modifying code, refactoring, before marking complete

## Code Style & Conventions

- **Naming**: Files kebab-case, Classes PascalCase, Methods camelCase, Constants UPPER_SNAKE_CASE
- **Imports**: External libraries first, then internal modules
- **Type Safety**: Strict mode, Prisma types, branded UIDs. **üö® NEVER use `any`/`unknown` to bypass errors** - fix types properly
- **Linting**: ESLint in `eslint.config.mjs`. **üö® NEVER disable rules** - fix underlying issues

## When Adding New Features

1. Follow established patterns
2. Extend `BaseRepository` for new entities
3. Create domain + admin layers
4. Use Zod schemas for validation
5. Handle errors with `HttpError` utility (never throw NestJS exceptions directly)
6. Check `docs/roadmap/PHASE_1.md` for phase status
7. Implement authentication per phase requirements
8. Write tests
9. Update documentation
10. Create constants files for shared values
11. **Verify code**: Run `pnpm lint`, `pnpm test`, `pnpm build`

## NestJS Best Practices

- **Modules**: Feature-based, export services from domain modules, use `@Global()` sparingly
- **DI**: Constructor injection, `@Injectable()` on all services, avoid circular deps
- **Guards**: `BaseApiKeyGuard` for service-to-service, JWT guards for users (see `docs/AUTHENTICATION_GUIDE.md`)
- **Exceptions**: Always use `HttpError` utility in services, global filters handle Prisma/Zod errors
- **Validation**: Zod schemas only, global validation pipes, `UidValidationPipe` for path params

## Anti-Patterns to Avoid

### Data & ID Management
- ‚ùå **Expose database IDs** - Always map `uid` ‚Üí `id` in DTOs
- ‚ùå **Include database ID in DTOs** - Only `uid` mapped as `id`
- ‚ùå **Use hard deletes** - Use soft delete consistently

### Architecture & Layers
- ‚ùå **Bypass service layer** - Controllers don't access repositories directly
- ‚ùå **Mix concerns** - Separate admin and domain logic
- ‚ùå **Create circular dependencies** - Use `forwardRef()` if absolutely necessary
- ‚ùå **Use `@Global()` excessively** - Only for truly global services

### Validation & Type Safety
- ‚ùå **Skip validation** - All inputs validated with Zod
- ‚ùå **Mix validation libraries** - Zod only
- ‚ùå **Ignore type safety** - Proper TypeScript types throughout
- ‚ùå **Use `any`/`unknown` to bypass errors** - Fix type issues properly

### Error Handling
- ‚ùå **Throw generic `Error` objects** - Use `HttpError` utility or let Prisma handle errors
- ‚ùå **Throw NestJS exceptions directly in services** - Always use `HttpError` utility
- ‚ùå **Throw HTTP exceptions in repositories** - Use Prisma's `findFirstOrThrow`/`findUniqueOrThrow`
- ‚ùå **Skip error handling** - Handle all error cases

### Performance
- ‚ùå **Create N+1 queries** - Use bulk ops instead of loops
- ‚ùå **Fetch related data in loops** - Use `include` in initial query
- ‚ùå **Run independent queries sequentially** - Use `Promise.all()`
- ‚ùå **Query count separately** - Use `Promise.all()` for parallel data + count
- ‚ùå **Build where clauses inline** - Use private `buildWhereClause()` methods
- ‚ùå **Forget transactions** - Use `prisma.$transaction()` for multiple operations

### Authentication & Security
- ‚ùå **Skip authentication** - Check phase requirements
- ‚ùå **Bypass authorization** - Check phase requirements
- ‚ùå **Ignore JWT validation** - Always validate tokens
- ‚ùå **Create API key guards from scratch** - Extend `BaseApiKeyGuard`
- ‚ùå **Expose API keys** - Environment variables only
- ‚ùå **Hardcode roles/types** - Use constants files

### Code Quality
- ‚ùå **Disable ESLint rules** - Fix underlying issues
- ‚ùå **Skip tests** - Write tests for new features

## Key Files

**Core:** `src/common/repositories/base.repository.ts`, `src/common/pagination/schema/pagination.schema.ts`, `src/common/pipes/uid-validation.pipe.ts`, `src/common/filters/*`, `src/common/errors/http-error.util.ts`, `src/utility/utility.service.ts`, `src/prisma/prisma.service.ts`, `src/membership/membership.service.ts`, `src/membership/membership.constants.ts`, `src/config/env.schema.ts`

**Docs:** `docs/roadmap/PHASE_1.md` (implementation status), `docs/AUTHENTICATION_GUIDE.md`, `docs/SERVER_TO_SERVER_AUTH.md`, `docs/ARCHITECTURE.md`, `docs/BUSINESS.md`

**Auth:** `src/common/guards/base-api-key.guard.ts`, `src/common/guards/google-sheets-api-key.guard.ts`

**For implementation status, always refer to `docs/roadmap/PHASE_1.md` as the single source of truth.**
